---
title: "Security Best Practices"
description: "Essential security practices for building on Paxeer Network"
icon: "shield-check"
---

## Overview

Security is paramount when building blockchain applications. This guide covers essential security practices for smart contract development on Paxeer Network.

<Warning>
**Security is critical.** A single vulnerability can lead to permanent loss of funds. Always prioritize security over speed of development.
</Warning>

## Smart Contract Security

### Use Audited Libraries

Always use well-tested, audited libraries like OpenZeppelin:

```solidity
// ‚úÖ Good: Use OpenZeppelin
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyToken is ERC20, Ownable {
    constructor() ERC20("MyToken", "MTK") Ownable(msg.sender) {}
}

// ‚ùå Bad: Roll your own implementation
contract MyToken {
    mapping(address => uint256) public balances;
    // Custom implementation may have bugs
}
```

<Card
  title="OpenZeppelin Contracts"
  icon="shield"
  href="https://docs.openzeppelin.com/contracts"
>
  Industry-standard secure smart contract library
</Card>

---

### Prevent Reentrancy Attacks

<Tabs>
  <Tab title="Checks-Effects-Interactions">
    Follow the CEI pattern:
    
    ```solidity
    function withdraw(uint256 amount) external {
        // ‚úÖ CHECKS: Validate conditions first
        require(balances[msg.sender] >= amount, "Insufficient balance");
        require(amount > 0, "Amount must be > 0");
        
        // ‚úÖ EFFECTS: Update state before external calls
        balances[msg.sender] -= amount;
        totalBalance -= amount;
        
        // ‚úÖ INTERACTIONS: External calls last
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
    ```
    
    **Why?** If you make external calls before updating state, malicious contracts can re-enter and drain funds.
  </Tab>

  <Tab title="ReentrancyGuard">
    Use OpenZeppelin's ReentrancyGuard:
    
    ```solidity
    import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

    contract Vault is ReentrancyGuard {
        mapping(address => uint256) public balances;
        
        function withdraw(uint256 amount) external nonReentrant {
            require(balances[msg.sender] >= amount);
            
            balances[msg.sender] -= amount;
            
            (bool success, ) = msg.sender.call{value: amount}("");
            require(success);
        }
    }
    ```
    
    **Benefit:** Prevents all reentrancy attacks automatically
  </Tab>
</Tabs>

---

### Access Control

Implement proper access control for sensitive functions:

<Tabs>
  <Tab title="Ownable">
    ```solidity
    import "@openzeppelin/contracts/access/Ownable.sol";

    contract MyContract is Ownable {
        constructor() Ownable(msg.sender) {}
        
        function adminFunction() external onlyOwner {
            // Only owner can call
        }
        
        function transferOwnership(address newOwner) public override onlyOwner {
            // Transfer ownership safely
            super.transferOwnership(newOwner);
        }
    }
    ```
  </Tab>

  <Tab title="AccessControl">
    ```solidity
    import "@openzeppelin/contracts/access/AccessControl.sol";

    contract MyContract is AccessControl {
        bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
        bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

        constructor() {
            _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
            _grantRole(ADMIN_ROLE, msg.sender);
        }

        function adminFunction() external onlyRole(ADMIN_ROLE) {
            // Only admins can call
        }

        function mint(address to, uint256 amount) 
            external 
            onlyRole(MINTER_ROLE) 
        {
            // Only minters can call
        }
    }
    ```
  </Tab>

  <Tab title="Custom Modifiers">
    ```solidity
    contract MyContract {
        address public owner;
        mapping(address => bool) public authorized;

        modifier onlyOwner() {
            require(msg.sender == owner, "Not owner");
            _;
        }

        modifier onlyAuthorized() {
            require(
                msg.sender == owner || authorized[msg.sender],
                "Not authorized"
            );
            _;
        }

        function criticalFunction() external onlyOwner {
            // Protected
        }

        function authorizedFunction() external onlyAuthorized {
            // Protected
        }
    }
    ```
  </Tab>
</Tabs>

---

### Input Validation

Always validate inputs:

```solidity
contract SecureContract {
    function transfer(address to, uint256 amount) external {
        // ‚úÖ Validate address
        require(to != address(0), "Invalid address");
        require(to != address(this), "Cannot transfer to self");
        
        // ‚úÖ Validate amount
        require(amount > 0, "Amount must be > 0");
        require(amount <= balances[msg.sender], "Insufficient balance");
        
        // ‚úÖ Check for overflow (automatic in 0.8+)
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
    
    function processBatch(address[] calldata recipients, uint256[] calldata amounts) 
        external 
    {
        // ‚úÖ Validate array lengths match
        require(recipients.length == amounts.length, "Length mismatch");
        
        // ‚úÖ Validate array not too large
        require(recipients.length <= 100, "Batch too large");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            require(recipients[i] != address(0), "Invalid recipient");
            require(amounts[i] > 0, "Invalid amount");
        }
    }
}
```

---

### Integer Overflow Protection

Solidity 0.8+ has built-in overflow protection:

```solidity
contract SafeMath {
    function add(uint256 a, uint256 b) public pure returns (uint256) {
        // ‚úÖ Automatically reverts on overflow in 0.8+
        return a + b;
    }
    
    function unsafeAdd(uint256 a, uint256 b) public pure returns (uint256) {
        // ‚ùå Can overflow - only use when certain it's safe
        unchecked {
            return a + b;
        }
    }
}
```

<Info>
Only use `unchecked` blocks when you're absolutely certain overflow is impossible, like incrementing a loop counter.
</Info>

---

### Safe External Calls

<Tabs>
  <Tab title="Send ETH Safely">
    ```solidity
    // ‚úÖ Good: Handle failures
    function sendETH(address payable to, uint256 amount) external {
        (bool success, ) = to.call{value: amount}("");
        require(success, "Transfer failed");
    }

    // ‚ùå Bad: Using transfer (can fail with gas limit)
    function sendETHBad(address payable to, uint256 amount) external {
        to.transfer(amount); // Only 2300 gas forwarded
    }

    // ‚ùå Bad: Using send without checking
    function sendETHWorse(address payable to, uint256 amount) external {
        to.send(amount); // Doesn't revert on failure!
    }
    ```
  </Tab>

  <Tab title="Call Other Contracts">
    ```solidity
    // ‚úÖ Good: Check return value
    function callExternal(address target, bytes calldata data) 
        external 
        returns (bytes memory) 
    {
        (bool success, bytes memory result) = target.call(data);
        require(success, "External call failed");
        return result;
    }

    // ‚úÖ Good: Use interfaces
    interface IERC20 {
        function transfer(address to, uint256 amount) external returns (bool);
    }

    function safeTransfer(address token, address to, uint256 amount) external {
        bool success = IERC20(token).transfer(to, amount);
        require(success, "Token transfer failed");
    }
    ```
  </Tab>
</Tabs>

---

## Common Vulnerabilities

<AccordionGroup>
  <Accordion title="Reentrancy" icon="arrows-rotate">
    **Risk Level:** üî¥ Critical
    
    **Example Attack:**
    ```solidity
    // Vulnerable contract
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        (bool success, ) = msg.sender.call{value: amount}(""); // ‚ùå External call first
        balances[msg.sender] = 0; // ‚ùå State update after
    }
    ```
    
    **Protection:**
    - Use ReentrancyGuard
    - Follow Checks-Effects-Interactions pattern
    - Update state before external calls
  </Accordion>

  <Accordion title="Front-Running" icon="forward-fast">
    **Risk Level:** üü° Medium
    
    **Description:** Attackers see pending transactions and submit their own with higher gas fees to execute first.
    
    **Mitigation:**
    - Use commit-reveal schemes
    - Implement minimum time delays
    - Use batch execution
    - Consider private mempools (Flashbots)
  </Accordion>

  <Accordion title="Integer Overflow/Underflow" icon="infinity">
    **Risk Level:** üü¢ Low (Solidity 0.8+)
    
    **Protection:**
    - Use Solidity 0.8+ (automatic protection)
    - Only use `unchecked` when absolutely safe
    - Test boundary conditions
  </Accordion>

  <Accordion title="Unchecked Return Values" icon="check">
    **Risk Level:** üü° Medium
    
    **Example:**
    ```solidity
    // ‚ùå Bad: Ignoring return value
    token.transfer(recipient, amount);
    
    // ‚úÖ Good: Checking return value
    bool success = token.transfer(recipient, amount);
    require(success, "Transfer failed");
    ```
  </Accordion>

  <Accordion title="Delegatecall Injection" icon="code">
    **Risk Level:** üî¥ Critical
    
    **Risk:** `delegatecall` executes code in context of caller
    
    **Protection:**
    ```solidity
    // ‚ùå Dangerous: User-controlled delegatecall
    function execute(address target, bytes calldata data) external {
        target.delegatecall(data); // Very dangerous!
    }
    
    // ‚úÖ Safe: Whitelist approved implementations
    mapping(address => bool) public approvedImplementations;
    
    function safeDelegatecall(address target, bytes calldata data) external {
        require(approvedImplementations[target], "Not approved");
        target.delegatecall(data);
    }
    ```
  </Accordion>

  <Accordion title="Access Control Issues" icon="lock-open">
    **Risk Level:** üî¥ Critical
    
    **Common Mistakes:**
    ```solidity
    // ‚ùå Bad: tx.origin for auth
    function withdraw() external {
        require(tx.origin == owner); // Can be bypassed!
    }
    
    // ‚úÖ Good: msg.sender for auth
    function withdraw() external {
        require(msg.sender == owner);
    }
    ```
  </Accordion>
</AccordionGroup>

## Security Tools

<CardGroup cols={2}>
  <Card
    title="Slither"
    icon="snake"
    href="https://github.com/crytic/slither"
  >
    Static analysis tool for Solidity
    
    ```bash
    pip3 install slither-analyzer
    slither .
    ```
  </Card>

  <Card
    title="Mythril"
    icon="hat-wizard"
    href="https://github.com/ConsenSys/mythril"
  >
    Security analysis tool
    
    ```bash
    pip3 install mythril
    myth analyze contracts/MyContract.sol
    ```
  </Card>

  <Card
    title="Echidna"
    icon="bug"
    href="https://github.com/crytic/echidna"
  >
    Fuzzing tool for smart contracts
  </Card>

  <Card
    title="Manticore"
    icon="magnifying-glass-chart"
    href="https://github.com/trailofbits/manticore"
  >
    Symbolic execution tool
  </Card>
</CardGroup>

## Security Checklist

Before deploying to mainnet:

### Development Phase
- [ ] Use latest Solidity version (0.8.20+)
- [ ] Import audited libraries (OpenZeppelin)
- [ ] Follow Checks-Effects-Interactions pattern
- [ ] Implement access control
- [ ] Validate all inputs
- [ ] Use ReentrancyGuard for functions with external calls
- [ ] Document all assumptions and invariants

### Testing Phase
- [ ] 90%+ test coverage
- [ ] Test all edge cases
- [ ] Fuzz test with Foundry/Echidna
- [ ] Test failure scenarios
- [ ] Test with maximum values
- [ ] Test access control
- [ ] Test reentrancy scenarios

### Analysis Phase
- [ ] Run Slither static analysis
- [ ] Run Mythril security scanner
- [ ] Manual code review
- [ ] Check for common vulnerabilities
- [ ] Review all external calls
- [ ] Verify all math operations

### Audit Phase
- [ ] Internal security review
- [ ] Peer review by team
- [ ] External audit by professionals (for high-value contracts)
- [ ] Bug bounty program (optional)

### Deployment Phase
- [ ] Deploy to testnet first
- [ ] Test all functions on testnet
- [ ] Verify contract on explorer
- [ ] Set up monitoring
- [ ] Prepare emergency response plan
- [ ] Document all admin functions

## Code Review Guidelines

<AccordionGroup>
  <Accordion title="Review External Calls" icon="phone">
    Identify and scrutinize all external calls:
    
    ```solidity
    // Look for:
    - .call()
    - .delegatecall()
    - .transfer()
    - .send()
    - External contract calls
    
    // Ask:
    - Can this reenter?
    - Is the recipient trusted?
    - Is the return value checked?
    - Is state updated before the call?
    ```
  </Accordion>

  <Accordion title="Check Access Control" icon="key">
    Verify all privileged functions:
    
    ```solidity
    // Questions to ask:
    - Who can call this function?
    - Is there a modifier protecting it?
    - Can ownership be renounced?
    - Are there emergency controls?
    - Is multi-sig recommended?
    ```
  </Accordion>

  <Accordion title="Review State Changes" icon="database">
    Analyze all state modifications:
    
    ```solidity
    // Check:
    - Are balances updated correctly?
    - Can state become inconsistent?
    - Are events emitted for changes?
    - Is data properly indexed?
    ```
  </Accordion>

  <Accordion title="Validate Math Operations" icon="calculator">
    Review arithmetic:
    
    ```solidity
    // Verify:
    - No overflow/underflow (unless unchecked)
    - Division by zero protection
    - Rounding handled correctly
    - Precision loss considered
    ```
  </Accordion>
</AccordionGroup>

## Emergency Procedures

### Pause Mechanism

Implement emergency pause:

```solidity
import "@openzeppelin/contracts/security/Pausable.sol";

contract EmergencyPausable is Pausable, Ownable {
    constructor() Ownable(msg.sender) {}
    
    function pause() external onlyOwner {
        _pause();
    }
    
    function unpause() external onlyOwner {
        _unpause();
    }
    
    function transfer(address to, uint256 amount) 
        external 
        whenNotPaused 
    {
        // Function pauses in emergency
    }
}
```

### Upgrade Patterns

<Tabs>
  <Tab title="Proxy Pattern">
    ```solidity
    // Use OpenZeppelin's upgradeable contracts
    import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
    import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
    import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

    contract MyTokenUpgradeable is 
        Initializable, 
        ERC20Upgradeable, 
        OwnableUpgradeable 
    {
        function initialize() public initializer {
            __ERC20_init("MyToken", "MTK");
            __Ownable_init(msg.sender);
        }
    }
    ```
  </Tab>

  <Tab title="Multi-Sig">
    ```solidity
    // Use Gnosis Safe for critical operations
    // Deploy multi-sig wallet
    // Transfer ownership to multi-sig
    
    contract MyContract is Ownable {
        constructor(address multiSig) Ownable(multiSig) {}
        
        // All admin functions require multi-sig approval
    }
    ```
  </Tab>
</Tabs>

## Testing for Security

### Security-Focused Tests

```javascript test/Security.test.js
describe("Security Tests", function () {
  it("Should prevent reentrancy", async function () {
    const Attacker = await ethers.getContractFactory("ReentrancyAttacker");
    const attacker = await Attacker.deploy(contract.address);
    
    await expect(
      attacker.attack()
    ).to.be.revertedWith("ReentrancyGuard: reentrant call");
  });

  it("Should prevent unauthorized access", async function () {
    await expect(
      contract.connect(user).adminFunction()
    ).to.be.revertedWith("Ownable: caller is not the owner");
  });

  it("Should handle zero address", async function () {
    await expect(
      contract.transfer(ethers.ZeroAddress, 100)
    ).to.be.revertedWith("Invalid address");
  });

  it("Should prevent integer overflow", async function () {
    const max = ethers.MaxUint256;
    await expect(
      contract.unsafeAdd(max, 1)
    ).to.be.reverted;
  });
});
```

### Invariant Testing (Foundry)

```solidity test/Invariants.t.sol
contract InvariantTest is Test {
    MyContract contract;
    
    function setUp() public {
        contract = new MyContract();
    }
    
    // Total supply should never change
    function invariant_totalSupply() public {
        assertEq(
            contract.totalSupply(),
            INITIAL_SUPPLY
        );
    }
    
    // Balance sum should equal total supply
    function invariant_balanceSum() public {
        uint256 sum = 0;
        address[] memory users = contract.getUsers();
        
        for (uint i = 0; i < users.length; i++) {
            sum += contract.balanceOf(users[i]);
        }
        
        assertEq(sum, contract.totalSupply());
    }
}
```

## Audit Preparation

### Documentation

Create comprehensive documentation:

```markdown
# Contract Documentation

## Overview
[What does this contract do?]

## Architecture
[How is it structured?]

## Functions
### Public Functions
- `function1()`: [Description, parameters, return values]
- `function2()`: [Description, parameters, return values]

### Admin Functions
- `adminFunc()`: [Description, access control, risks]

## Security Considerations
[Known risks and mitigations]

## Dependencies
[External contracts and libraries]

## Assumptions
[What assumptions does the code make?]
```

### Prepare Audit Package

```
audit-package/
‚îú‚îÄ‚îÄ contracts/          # All contract source files
‚îú‚îÄ‚îÄ test/              # Comprehensive test suite
‚îú‚îÄ‚îÄ docs/              # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ architecture.md
‚îÇ   ‚îú‚îÄ‚îÄ security.md
‚îÇ   ‚îî‚îÄ‚îÄ functions.md
‚îú‚îÄ‚îÄ audit-scope.md     # What to audit
‚îî‚îÄ‚îÄ known-issues.md    # Known limitations
```

## Getting Audited

<CardGroup cols={2}>
  <Card
    title="Trail of Bits"
    icon="shield"
    href="https://www.trailofbits.com"
  >
    Leading security auditors
  </Card>
  <Card
    title="OpenZeppelin"
    icon="shield-check"
    href="https://www.openzeppelin.com/security-audits"
  >
    Smart contract audits
  </Card>
  <Card
    title="ConsenSys Diligence"
    icon="shield"
    href="https://consensys.net/diligence"
  >
    Security services
  </Card>
  <Card
    title="Code4rena"
    icon="users"
    href="https://code4rena.com"
  >
    Competitive audits
  </Card>
</CardGroup>

## Bug Bounty Programs

Consider running a bug bounty:

```markdown
# Bug Bounty Program

## Rewards
- Critical: $10,000 - $50,000
- High: $5,000 - $10,000
- Medium: $1,000 - $5,000
- Low: $100 - $1,000

## Scope
- All smart contracts at [addresses]
- Vulnerabilities that lead to loss of funds
- Access control bypasses
- Economic attacks

## Out of Scope
- Known issues
- Gas optimizations
- UI/UX issues

## Reporting
Submit to security@yourproject.com
```

## Resources

<CardGroup cols={2}>
  <Card
    title="Smart Contract Security Field Guide"
    icon="book"
    href="https://scsfg.io"
  >
    Comprehensive security guide
  </Card>
  <Card
    title="Ethereum Smart Contract Best Practices"
    icon="book"
    href="https://consensys.github.io/smart-contract-best-practices"
  >
    ConsenSys security guide
  </Card>
  <Card
    title="SWC Registry"
    icon="list"
    href="https://swcregistry.io"
  >
    Smart contract weakness classification
  </Card>
  <Card
    title="Secureum"
    icon="graduation-cap"
    href="https://secureum.xyz"
  >
    Security education
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Testing Apps"
    icon="flask"
    href="/app-developers/guides/testing-apps"
  >
    Testing best practices
  </Card>
  <Card
    title="Building Apps"
    icon="hammer"
    href="/app-developers/guides/building-apps"
  >
    Development guide
  </Card>
  <Card
    title="Examples"
    icon="code"
    href="/examples"
  >
    Secure code examples
  </Card>
</CardGroup>

